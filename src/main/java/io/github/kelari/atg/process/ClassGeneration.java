package io.github.kelari.atg.process;

import io.github.kelari.atg.model.CaseTest;
import io.github.kelari.atg.model.ClassTest;
import com.squareup.javapoet.*;
import io.github.kelari.atg.model.SpecScenariosTest;
import io.github.kelari.atg.process.helper.ClassGenerationHelper;
import io.github.kelari.atg.util.CompilerLogger;
import io.github.kelari.atg.util.Constants;
import io.github.kelari.atg.util.Predicates;

import javax.lang.model.element.Modifier;
import javax.tools.Diagnostic;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.function.Predicate;

/**
 * A utility class for generating test classes with methods based on annotations.
 * This class helps in writing test classes with autogenerated test methods for HTTP endpoints
 * using JavaPoet and metadata defined in {@code ClassTest} and related models.
 * <p>
 * It supports conditional generation for multipart and authenticated endpoints.
 * </p>
 *
 * <p>Example generated structure includes:</p>
 * <ul>
 *   <li>Class-level annotations (e.g. {@code @SpringBootTest})</li>
 *   <li>Injection of {@code WebTestClient}</li>
 *   <li>Test methods per HTTP scenario</li>
 *   <li>Authentication handling if required</li>
 *   <li>Helper methods for multipart uploads</li>
 * </ul>
 *
 * @author <a href="mailto:agsn10@hotmail.com">Antonio Neto</a> [<()>] â€“ Initial implementation.
 * @since 1.0
 * @version 1.0
 * @copyright 2025 Kelari. All rights reserved.
 */
public final class ClassGeneration implements CompilerLogger {

    /**
     * List of {@link ClassTest} instances representing the metadata
     * for the classes and test scenarios to be generated.
     */
    private final List<ClassTest> classTestList;

    /**
     * Logger instance used for outputting messages during compilation/generation.
     */
    private CompilerLogger compilerLogger;

    /**
     * Stores the hash codes of already generated class definitions to avoid duplication.
     */
    private final Set<Integer> generatedClassNames = new HashSet<>();

    /**
     * Constructs a new instance of {@code ClassGeneration} with the provided class metadata list.
     *
     * @param classTestList List of class metadata used to generate the test classes
     */
    public ClassGeneration(List<ClassTest> classTestList) {
        this.classTestList = classTestList;
    }

    /**
     * Sets a logger implementation for reporting messages during code generation.
     *
     * @param logger the {@link CompilerLogger} to be used
     */
    public void setCompilerLogger(CompilerLogger logger) {
        this.compilerLogger = logger;
    }

    /**
     * Logs a message to the provided compiler logger, if set.
     *
     * @param kind    the kind of diagnostic message
     * @param message the message to be logged
     */
    public void log(Diagnostic.Kind kind, String message) {
        if (Objects.nonNull(compilerLogger))
            compilerLogger.log(kind, message);
    }

    /**
     * Main entry point for generating all test classes.
     * Iterates over the provided {@link ClassTest} list and creates Java source files using JavaPoet.
     *
     * - Adds Spring annotations.
     * - Adds WebTestClient injection.
     * - Generates each method from te provided HTTP test cases.
     * - Conditionally includes authentication and multipart handling logic.
     */
    public void generateTestClass() {
        this.classTestList.stream().forEach(classTest -> {

            int hash = classTest.hashCode();
            if (generatedClassNames.add(hash)) {

                FieldSpec webTestClientField = FieldSpec.builder(Constants.Imports.WEB_TEST_CLIENT, Constants.WEB_TEST_CLIENT_CLASS_INSTANCE_NAME, Modifier.PRIVATE)
                        .addAnnotation(Constants.Imports.AUTOWIRED)
                        .build();

                List<MethodSpec> methods = new ArrayList<>();
                MethodSpec buildMultipartData = null;
                if (Predicates.SHOULD_GENERATE_MULTIPART_METHOD.test(classTest)) {
                    buildMultipartData = ClassGenerationHelper.generateBuildMultipartDataMethod();
                    methods.add(buildMultipartData);
                }

                FieldSpec bearerTokenField = null;
                MethodSpec authenticate = null;
                Predicate<ClassTest> combined = Predicates.SHOULD_GENERATE_AUTH_TOKEN.and(Predicates.IS_REQUIRE_AUTH);
                if (combined.test(classTest)) {
                    bearerTokenField = FieldSpec.builder(String.class, Constants.ATTRIBUTE_CLASS_TEST_BEARER_TOKEN, Modifier.PRIVATE)
                            .initializer("$S", "")
                            .build();
                    authenticate = ClassGenerationHelper.generateAuthBeforeEachMethod(
                                                        classTest.getAuthTest().getAuthUrl(),
                                                        classTest.getAuthTest().getUsername(),
                                                        classTest.getAuthTest().getPassword(),
                                                        classTest.getAuthTest().getParameterTokenName());
                    methods.add(authenticate);
                }

                List<MethodSpec> testMethods = new ArrayList<>();
                for (SpecScenariosTest specScenariosTest : classTest.values()) {
                    String fullPath = (Objects.nonNull(classTest.getPathBase()) ? classTest.getPathBase() : "").concat(specScenariosTest.getPathMethod());
                    for (CaseTest caseTest : specScenariosTest.getCaseTestList())
                        testMethods.add(ClassGenerationHelper.generateTestMethod(specScenariosTest, caseTest, fullPath));

                }
                methods.addAll(testMethods);

                TypeSpec.Builder classBuilder = TypeSpec.classBuilder(classTest.getName())
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(AnnotationSpec.builder(Constants.Imports.SPRING_BOOT_TEST)
                                .addMember(Constants.SPRING_BOOT_TEST_CONTEXT_NAME, Constants.SPRING_BOOT_TEST_CONTEXT_FORMAT, Constants.Imports.WEB_ENVIRONMENT)
                                .build())
                        .addAnnotation(Constants.Imports.AUTO_CONFIGURE_WEB_TEST_CLIENT)
                        .addField(webTestClientField);

                if (Objects.nonNull(bearerTokenField)) classBuilder.addField(bearerTokenField);
                classBuilder.addMethods(methods);
                TypeSpec clazz = classBuilder.build();

                try {
                    JavaFile javaFile = JavaFile.builder(classTest.getPackageName(), clazz)
                            .addFileComment("import static io.github.kelari.atg.util.DataLoadUtil.*;")
                            .build();
                    String raw = javaFile.toString();
                    String updated = raw.replace(
                            "package " + classTest.getPackageName() + ";",
                            "package " + classTest.getPackageName() + ";\n\nimport static io.github.kelari.atg.util.DataLoadUtil.*;"
                    );
                    updated = updated.replace("// import static io.github.kelari.atg.util.DataLoadUtil.*;",
                                         "// Generated by Kelari - API Test Generator"
                    );
                    String testSrcDir = System.getProperty("user.dir") + "/src/test/java/" + classTest.getPackageName().replace('.', '/') + "/" + classTest.getName() + ".java";
                    Files.write(Paths.get(testSrcDir), updated.getBytes(StandardCharsets.UTF_8));
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        });
    }

}